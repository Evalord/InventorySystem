package com.inventory.core;

import com.inventory.dao.ProductDAO;
import java.util.Objects;
import java.util.concurrent.TimeUnit;

/**
 * Manages inventory operations, acting as a service layer.
 * It delegates persistence operations to a ProductDAO.
 */
public class InventoryManager {

    private final ProductDAO productDAO;

    public InventoryManager(ProductDAO productDAO) {
        this.productDAO = Objects.requireNonNull(productDAO, "ProductDAO cannot be null");
    }

    /* ----- Core Business Operations ----- */

    public void addProduct(Product product) throws InventoryException {
        Objects.requireNonNull(product, "Product cannot be null");

        // For new products, ID might be null (will be generated by database)
        if (product.getId() != null) {
            validateId(product.getId());
        }

        productDAO.addProduct(product);
        System.out.println("InventoryManager: Product '" + product.getName() + "' added with ID: " + product.getId());
    }

    public Product getProduct(String productId) throws InventoryException {
        validateId(productId);
        Product product = productDAO.getProductById(productId);
        if (product == null) {
            throw new InventoryException("Product not found with ID: " + productId);
        }
        return product;
    }

    public Product getProductByName(String productName) throws InventoryException {
        if (productName == null || productName.trim().isEmpty()) {
            throw new InventoryException("Product name cannot be null or empty.");
        }
        Product product = productDAO.getProductByName(productName.trim());
        if (product == null) {
            throw new InventoryException("Product not found with name: " + productName);
        }
        return product;
    }

    public void updateProduct(Product product) throws InventoryException {
        Objects.requireNonNull(product, "Product for update cannot be null");
        validateId(product.getId());

        // Verify product exists before update
        Product existing = getProduct(product.getId());
        if (existing == null) {
            throw new InventoryException("Cannot update - product not found with ID: " + product.getId());
        }

        productDAO.updateProduct(product);
        System.out.println("InventoryManager: Product " + product.getId() + " updated.");
    }

    public boolean removeProduct(String productId) throws InventoryException {
        validateId(productId);
        boolean removed = productDAO.deleteProduct(productId);
        if (removed) {
            System.out.println("InventoryManager: Product " + productId + " removed.");
        } else {
            System.out.println("InventoryManager: Product " + productId + " not found for removal.");
        }
        return removed;
    }

    public int calculateProductQuantity(String productId) throws InventoryException {
        validateId(productId);
        System.out.println("InventoryManager: Calculating quantity for product " + productId);
        return productDAO.calculateProductQuantity(productId);
    }

    public boolean transferStock(String sourceId, String targetId, int amount,
                                 long timeout, TimeUnit unit)
            throws InventoryException, InterruptedException {

        if (amount <= 0) {
            throw new InventoryException("Transfer amount must be positive");
        }
        if (sourceId.equals(targetId)) {
            throw new InventoryException("Cannot transfer to the same product");
        }

        // Get products with null checks
        Product source = getProduct(sourceId);
        Product target = getProduct(targetId);

        if (source == null || target == null) {
            throw new InventoryException("Source or target product not found");
        }

        // Establish global lock ordering using String IDs (alphabetical order)
        Product first, second;
        if (source.getId().compareTo(target.getId()) < 0) {
            first = source;
            second = target;
        } else {
            first = target;
            second = source;
        }

        // Attempt lock acquisition
        boolean firstLocked = first.getLock().tryLock(timeout, unit);
        if (!firstLocked) {
            System.out.println("DEBUG: Failed to acquire lock for first product: " + first.getId());
            return false;
        }

        try {
            boolean secondLocked = second.getLock().tryLock(timeout, unit);
            if (!secondLocked) {
                System.out.println("DEBUG: Failed to acquire lock for second product: " + second.getId());
                return false;
            }

            try {
                // Check stock availability
                if (source.getQuantity() < amount) {
                    throw new InventoryException("Insufficient stock in source product: " + sourceId +
                            ". Available: " + source.getQuantity() + ", Requested: " + amount);
                }

                // Perform transfer
                source.removeStock(amount);
                target.addStock(amount);

                // Persist changes
                productDAO.updateProduct(source);
                productDAO.updateProduct(target);

                System.out.println("InventoryManager: Stock transfer successful from " + source.getId() + " to " + target.getId());
                return true;
            } finally {
                second.getLock().unlock();
            }
        } finally {
            first.getLock().unlock();
        }
    }

    /* ----- Utility Methods ----- */

    /**
     * Validates if a product ID (passed as String) is not null or empty.
     * For new products, ID might be null initially.
     */
    private void validateId(String id) throws InventoryException {
        if (id == null || id.trim().isEmpty()) {
            throw new InventoryException("Product ID cannot be null or empty");
        }
    }

    public void shutdown() {
        System.out.println("InventoryManager shutdown initiated.");
    }
}